
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>database: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/alexgiesting/gillings-search/go/database/collection.go (66.7%)</option>
				
				<option value="file1">github.com/alexgiesting/gillings-search/go/database/connect.go (73.3%)</option>
				
				<option value="file2">github.com/alexgiesting/gillings-search/go/database/load.go (0.0%)</option>
				
				<option value="file3">github.com/alexgiesting/gillings-search/go/query/query.go (0.0%)</option>
				
				<option value="file4">github.com/alexgiesting/gillings-search/go/update/pull.go (0.0%)</option>
				
				<option value="file5">github.com/alexgiesting/gillings-search/go/update/push.go (0.0%)</option>
				
				<option value="file6">github.com/alexgiesting/gillings-search/go/update/update.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package database

import (
        "context"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// TODO pare down!!

type Collection struct {
        mongo *mongo.Collection
}

func (collection *Collection) Drop(ctx context.Context) error <span class="cov8" title="1">{
        return collection.mongo.Drop(ctx)
}</span>

func (collection *Collection) Insert(item interface{}) error <span class="cov8" title="1">{
        document, err := bson.Marshal(item)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = collection.mongo.InsertOne(context.TODO(), document)
        return err</span>
}

func (collection *Collection) Decode(results interface{}) error <span class="cov8" title="1">{
        cursor, err := collection.mongo.Find(context.TODO(), bson.D{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return cursor.All(context.TODO(), results)</span>
}

type Search struct {
        collection *mongo.Collection
        filter     []bson.D
        project    bson.D
}
type Projection Search

func (collection *Collection) Search() *Search <span class="cov0" title="0">{
        return newSearch(collection)
}</span>

func (collection *Collection) Filter(key string, filter interface{}) *Search <span class="cov8" title="1">{
        return newSearch(collection).Filter(key, filter)
}</span>

func (collection *Collection) Project(includeFields ...string) *Projection <span class="cov0" title="0">{
        return newSearch(collection).Project(includeFields...)
}</span>

func newSearch(collection *Collection) *Search <span class="cov8" title="1">{
        filter := []bson.D{}
        project := bson.D{}
        return &amp;Search{collection.mongo, filter, project}
}</span>

func (search *Search) makeFilter() bson.D <span class="cov8" title="1">{
        if len(search.filter) &gt; 1 </span><span class="cov0" title="0">{
                return bson.D{{Key: "$and", Value: search.filter}}
        }</span> else<span class="cov8" title="1"> if len(search.filter) == 1 </span><span class="cov8" title="1">{
                return search.filter[0]
        }</span>
        <span class="cov0" title="0">return bson.D{}</span>
}

func (search *Search) Filter(key string, filter interface{}) *Search <span class="cov8" title="1">{
        search.filter = append(search.filter, bson.D{{Key: key, Value: filter}})
        return search
}</span>

func (search *Search) Check() (bool, error) <span class="cov0" title="0">{
        result := search.collection.FindOne(context.TODO(), search.makeFilter())
        if result.Err() == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                return false, nil
        }</span> else<span class="cov0" title="0"> if result.Err() != nil </span><span class="cov0" title="0">{
                return false, result.Err()
        }</span> else<span class="cov0" title="0"> {
                return true, nil
        }</span>
}

func (search *Search) Decode(results interface{}) error <span class="cov8" title="1">{
        cursor, err := search.collection.Find(context.TODO(), search.makeFilter())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return cursor.All(context.TODO(), results)</span>
}

func (search *Search) Project(fields ...string) *Projection <span class="cov8" title="1">{
        for _, field := range fields </span><span class="cov8" title="1">{
                search.project = append(search.project, bson.E{Key: field, Value: 1})
        }</span>
        <span class="cov8" title="1">return (*Projection)(search)</span>
}

func (projection *Projection) Decode(results interface{}) error <span class="cov8" title="1">{
        filter := (*Search)(projection).makeFilter()
        option := options.Find().SetProjection(projection.project)
        cursor, err := projection.collection.Find(context.TODO(), filter, option)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return cursor.All(context.TODO(), results)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package database

import (
        "context"
        "fmt"
        "log"
        "os"

        "github.com/alexgiesting/gillings-search/go/paths"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type Connection struct {
        db          *mongo.Database
        client      *mongo.Client
        meta        *Collection
        Departments *Collection
        Faculty     *Collection
        Citations   *Collection
        Themes      *Collection
}

func (conn *Connection) Disconnect(ctx context.Context) error <span class="cov0" title="0">{
        return conn.client.Disconnect(ctx)
}</span>

func (conn *Connection) Clear(ctx context.Context) error <span class="cov0" title="0">{
        return conn.meta.Drop(ctx)
}</span>

func Connect() *Connection <span class="cov8" title="1">{
        DB_HOST := os.Getenv(paths.ENV_MONGODB_HOST)
        DB_PORT := os.Getenv(paths.ENV_MONGODB_PORT)
        DB_ADMIN_PASSWORD := os.Getenv(paths.ENV_MONGODB_ADMIN_PASSWORD)
        DB_NAME := os.Getenv(paths.ENV_MONGODB_NAME)

        DB_CREDENTIALS := ""
        if DB_ADMIN_PASSWORD != "" </span><span class="cov0" title="0">{
                DB_CREDENTIALS = fmt.Sprintf("admin:%s@", DB_ADMIN_PASSWORD)
        }</span>
        <span class="cov8" title="1">DB_URI := fmt.Sprintf("mongodb://%s%s:%s/", DB_CREDENTIALS, DB_HOST, DB_PORT)
        client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI(DB_URI))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to MongoDB: %v\n", err)
        }</span>
        <span class="cov8" title="1">db := client.Database(DB_NAME)

        return &amp;Connection{
                db:          db,
                client:      client,
                meta:        &amp;Collection{mongo: db.Collection(META)},
                Departments: &amp;Collection{mongo: db.Collection(DEPARTMENTS)},
                Faculty:     &amp;Collection{mongo: db.Collection(FACULTY)},
                Citations:   &amp;Collection{mongo: db.Collection(CITATIONS)},
                Themes:      &amp;Collection{mongo: db.Collection(THEMES)},
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "context"
        "encoding/csv"
        "encoding/xml"
        "io"
        "io/ioutil"
        "log"
        "strings"
)

const (
        META        = "__dbinfo__"
        DEPARTMENTS = "Departments"
        FACULTY     = "Faculty"
        CITATIONS   = "Citations"
        THEMES      = "Themes"
)

func (db *Connection) LoadFaculty(facultyCSV io.Reader) <span class="cov0" title="0">{
        lines, err := csv.NewReader(facultyCSV).ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fields := make(map[string]int)
        for c, label := range lines[0] </span><span class="cov0" title="0">{
                fields[label] = c
        }</span>
        <span class="cov0" title="0">NAME := fields["Name"]
        TITLE := fields["Title"]
        SID := fields["Scopus ID"]
        EMAIL := fields["E-mail"]
        STRENGTHS := fields["Strengths"]

        faculty := make([]interface{}, len(lines)-1)
        for r, row := range lines[1:] </span><span class="cov0" title="0">{
                faculty[r] = Faculty{
                        Name:      row[NAME],
                        Title:     row[TITLE],
                        SID:       getSIDs(row[SID]),
                        Email:     row[EMAIL],
                        Strengths: getStrengths(row[STRENGTHS]),
                }
        }</span>

        <span class="cov0" title="0">_, err = db.Faculty.mongo.InsertMany(context.TODO(), faculty)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func getSIDs(sidsString string) []string <span class="cov0" title="0">{
        if sidsString == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov0" title="0">return strings.Split(sidsString, ",")</span>
}

func getStrengths(strengthsString string) []Strength <span class="cov0" title="0">{
        if strengthsString == "" </span><span class="cov0" title="0">{
                return []Strength{}
        }</span>
        <span class="cov0" title="0">strengthsStrings := strings.Split(strengthsString, ",")
        strengths := make([]Strength, len(strengthsStrings))
        for i, strength := range strengthsStrings </span><span class="cov0" title="0">{
                parts := strings.Split(strength, ":")
                strengths[i].ThemeAbbr = parts[0]
                strengths[i].SubThemeAbbr = parts[1]
        }</span>
        <span class="cov0" title="0">return strengths</span>
}

func (db *Connection) LoadThemes(themesXML io.Reader) <span class="cov0" title="0">{
        themesBytes, err := ioutil.ReadAll(themesXML)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">var themes struct {
                Themes []Theme `xml:"theme"`
        }
        err = xml.Unmarshal(themesBytes, &amp;themes)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">for _, theme := range themes.Themes </span><span class="cov0" title="0">{
                _, err = db.Themes.mongo.InsertOne(context.TODO(), theme)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }
}

func (db *Connection) LoadCitations(citationsJSON io.Reader) {<span class="cov0" title="0">
        // TODO
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package query

import (
        "context"
        "encoding/json"
        "log"
        "net/http"
        "os"

        "github.com/alexgiesting/gillings-search/go/database"
        "github.com/alexgiesting/gillings-search/go/paths"
        "go.mongodb.org/mongo-driver/bson"
)

type QueryHandler struct {
        db *database.Connection
}

func (handler *QueryHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // path := r.URL.Path[len(paths.PATH_QUERY):] // TODO
        query := r.URL.Query()
        var querySearch bson.M
        json.Unmarshal([]byte(query.Get("q")), &amp;querySearch)

        search := handler.db.Citations.Filter(makeSearch(querySearch))
        var results []database.Citation
        err := search.Decode(&amp;results)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        err = json.NewEncoder(w).Encode(results)
        // err = json.NewEncoder(w).Encode(struct{ Results []database.Citation }{Results: results}),
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func d(key string, value interface{}) bson.D <span class="cov0" title="0">{
        return bson.D{{Key: key, Value: value}}
}</span>

func makeSearch(document bson.M) (string, []bson.D) <span class="cov0" title="0">{
        // TODO limit/paginate results
        // TODO validate fields
        filter := []bson.D{}
        for k, v := range document </span><span class="cov0" title="0">{
                switch k </span>{
                case "or":<span class="cov0" title="0">
                        orFilter := []bson.D{}
                        for _, w := range v.([]interface{}) </span><span class="cov0" title="0">{
                                orDocument := w.(bson.M)
                                orFilter = append(orFilter, d(makeSearch(orDocument)))
                        }</span>
                        <span class="cov0" title="0">filter = append(filter, d("$or", orFilter))</span>
                case "keyword":<span class="cov0" title="0">
                        filter = append(filter, match(v, "keywords", "title", "abstract"))</span>
                case "faculty":<span class="cov0" title="0">
                        filter = append(filter, match(v, "authors.name"))</span>
                // case "dept": // TODO
                // case "theme": // TODO
                default:<span class="cov0" title="0">
                        log.Printf("Unrecognized parameter `%s` with value: %v", k, v)</span>
                }
        }
        <span class="cov0" title="0">return "$and", filter</span>
}

func match(v interface{}, fields ...string) bson.D <span class="cov0" title="0">{
        words := v.([]interface{})
        if len(words) == 1 </span><span class="cov0" title="0">{
                return matchElement(words[0].(string), fields)
        }</span> else<span class="cov0" title="0"> {
                filter := make([]bson.D, len(words))
                for i, word := range words </span><span class="cov0" title="0">{
                        filter[i] = matchElement(word.(string), fields)
                }</span>
                <span class="cov0" title="0">return d("$and", filter)</span>
        }
}

func matchElement(word string, fields []string) bson.D <span class="cov0" title="0">{
        // TODO figure out how text indices work :(
        // matchWord := d("$text", d("$search", word))
        matchWord := bson.D{{Key: "$regex", Value: "\\b" + word}, {Key: "$options", Value: "i"}}
        if len(fields) == 1 </span><span class="cov0" title="0">{
                return d(fields[0], matchWord)
        }</span> else<span class="cov0" title="0"> {
                alternatives := make([]bson.D, len(fields))
                for j, field := range fields </span><span class="cov0" title="0">{
                        alternatives[j] = d(field, matchWord)
                }</span>
                <span class="cov0" title="0">return d("$or", alternatives)</span>
        }
}

func Main() <span class="cov0" title="0">{
        db := database.Connect()
        defer db.Disconnect(context.TODO())

        serveMux := http.NewServeMux()
        serveMux.Handle(paths.PATH_QUERY, &amp;QueryHandler{db})

        PORT := os.Getenv(paths.ENV_QUERY_PORT)
        log.Printf("Running server on %s", PORT)
        log.Fatal(http.ListenAndServe(":"+PORT, serveMux))
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package update

import (
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "net/url"
        "os"
        "strconv"
        "strings"

        "github.com/alexgiesting/gillings-search/go/database"
        "github.com/alexgiesting/gillings-search/go/paths"
)

func pullCitations(db *database.Connection, startDate string) <span class="cov0" title="0">{
        apiKey, err := os.ReadFile(paths.SECRET_SCOPUS_API_KEY)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        // TODO only load on local runs
        <span class="cov0" title="0">apiClient, _ := os.ReadFile(paths.SECRET_SCOPUS_CLIENT_ADDRESS)

        limiter := make(chan int, 8)
        for _, sids := range getSIDs(db) </span><span class="cov0" title="0">{
                if len(sids) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">limiter &lt;- 1
                go func(sids []string) </span><span class="cov0" title="0">{
                        entries := queryScopus(sids, startDate, string(apiKey), string(apiClient))
                        for _, entry := range entries </span><span class="cov0" title="0">{
                                exists, err := db.Citations.Filter("eid", entry.EID).Check()
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Fatal(err)
                                }</span>
                                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                                        addCitation(db, &amp;entry)
                                }</span>
                        }
                        <span class="cov0" title="0">&lt;-limiter</span>
                }(sids)
                // TODO make a version that only adds recent results
                // TODO make a version that alters records based on faculty changes
                // TODO make sure process can recover from interruptions
        }
}

func getSIDs(db *database.Connection) [][]string <span class="cov0" title="0">{
        // TODO this crashes if faculty hasn't been created yet
        var sidLists []struct{ SID []string }
        err := db.Faculty.Project("sid").Decode(&amp;sidLists)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">sids := make([][]string, len(sidLists))
        for i, sidList := range sidLists </span><span class="cov0" title="0">{
                sids[i] = sidList.SID
        }</span>
        <span class="cov0" title="0">return sids</span>
}

// type ScopusQuery struct {
//         Accept           string `json:"httpAccept"` // application/json, application/atom+xml, application/xml
//         AccessToken      string `json:"access_token"`
//         InstitutionToken string `json:"insttoken"`
//         APIKey           string `json:"apiKey"`
//         RequestID        string `json:"reqId"`
//         ResourceVersion  string `json:"ver"` // facetexpand, new
//         Query            string `json:"query"`
//         View             string `json:"view"` // STANDARD, COMPLETE
//         SuppressNavLinks bool   `json:"suppressNavLinks"`
//         Year             string `json:"date"`
//         Offset           uint   `json:"start"`
//         Count            uint   `json:"count"`
//         Sort             string `json:"sort"`    // artnum, citedby-count, coverDate, creator, orig-load-date, pagecount, pagefirst, pageRange, publicationName, pubyear, relevancy, volume
//         Content          string `json:"content"` // core, dummy, all
//         Subject          string `json:"subj"`
//         UseAuthorAlias   bool   `json:"alias"`
//         Cursor           string `json:"cursor"`
//         Facets           string `json:"facets"`
// }

type ScopusResult struct {
        Results struct {
                Citations []Entry `json:"entry"`
                Count     string  `json:"opensearch:totalResults"`
        } `json:"search-results"`
}

type Entry struct {
        EID          string `json:"eid"`
        Title        string `json:"dc:title"`
        Author       string `json:"dc:creator"`
        PubType      string `json:"prism:aggregationType"`
        PubName      string `json:"prism:publicationName"`
        SubType      string `json:"subtypeDescription"`
        Volume       string `json:"prism:volume"`
        Issue        string `json:"prism:issueIdentifier"`
        Pages        string `json:"prism:pageRange"`
        Date         string `json:"prism:coverDisplayDate"`
        ISODate      string `json:"prism:coverDate"`
        DOI          string `json:"prism:doi"`
        Abstract     string `json:"dc:description"`
        CitedByCount string `json:"citedby-count"`
        Keywords     string `json:"authkeywords"`
        Authors      []struct {
                SID          string `json:"authid"`
                Name         string `json:"authname"`
                GivenName    string `json:"given-name"`
                Surname      string `json:"surname"`
                Initials     string `json:"initials"`
                Affiliations []struct {
                        SID string `json:"$"`
                } `json:"afid"`
        } `json:"author"`
        Affiliations []struct {
                SID     string `json:"afid"`
                Name    string `json:"affilname"`
                City    string `json:"affiliation-city"`
                Country string `json:"affiliation-country"`
                Alias   []struct {
                        Name string `json:"$"`
                } `json:"name-variant"`
        } `json:"affiliation"`
}

func queryScopus(sids []string, startDate string, apiKey string, apiClient string) []Entry <span class="cov0" title="0">{
        // TODO use date to limit results
        // TODO use EID to limit results
        // TODO monitor rate limits, request ids, errors...
        // TODO add progress logging
        fields := make([]string, len(sids))
        for i, sid := range sids </span><span class="cov0" title="0">{
                fields[i] = fmt.Sprintf("AU-ID(%s)", sid)
        }</span>
        <span class="cov0" title="0">query := url.QueryEscape(strings.Join(fields, " OR "))
        url := fmt.Sprintf("https://api.elsevier.com/content/search/scopus?query=%s&amp;view=COMPLETE", query)

        var entries []Entry
        var start int = 0
        var count int
        for </span><span class="cov0" title="0">{
                startField := fmt.Sprintf("&amp;start=%d", start)
                request, err := http.NewRequest("GET", url+startField, nil)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">request.Header.Set("Accept", "application/json")
                request.Header.Set("X-ELS-APIKey", apiKey)
                if apiClient != "" </span><span class="cov0" title="0">{
                        request.Header.Set("X-Forwarded-For", apiClient)
                }</span>

                <span class="cov0" title="0">response, err := http.DefaultClient.Do(request)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">body, err := io.ReadAll(response.Body)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">var result ScopusResult
                err = json.Unmarshal(body, &amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">if start == 0 </span><span class="cov0" title="0">{
                        i, err := strconv.Atoi(result.Results.Count)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err, url+startField, response, string(body), result)
                        }</span>
                        <span class="cov0" title="0">count = i
                        entries = make([]Entry, 0, count)</span>
                }
                <span class="cov0" title="0">entries = append(entries, result.Results.Citations...)
                start += len(result.Results.Citations)
                if start &gt;= count </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return entries</span>
}

func addCitation(db *database.Connection, entry *Entry) <span class="cov0" title="0">{
        err := db.Citations.Insert(database.Citation{
                Title:        entry.Title,
                PubType:      entry.PubType,
                PubName:      entry.PubName,
                SubType:      entry.SubType,
                Volume:       entry.Volume,
                Issue:        entry.Issue,
                Pages:        entry.Pages,
                Date:         entry.Date,
                ISODate:      entry.ISODate,
                DOI:          entry.DOI,
                Abstract:     entry.Abstract,
                CitedByCount: entry.getCitedByCount(),
                Keywords:     entry.getKeywords(),
                EID:          entry.EID,
                Authors:      entry.getAuthors(),
                Affiliations: entry.getAffiliations(),
                Status:       database.STATUS_UNCONFIRMED,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func (entry *Entry) getCitedByCount() int <span class="cov0" title="0">{
        citedByCount, err := strconv.Atoi(entry.CitedByCount)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return citedByCount</span>
}

func (entry *Entry) getKeywords() []string <span class="cov0" title="0">{
        if entry.Keywords == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span> else<span class="cov0" title="0"> {
                return strings.Split(entry.Keywords, " | ")
        }</span>
}

func (entry *Entry) getAuthors() []database.Author <span class="cov0" title="0">{
        authors := make([]database.Author, len(entry.Authors))
        for i, author := range entry.Authors </span><span class="cov0" title="0">{
                affiliations := make([]string, len(author.Affiliations))
                for i, affiliation := range author.Affiliations </span><span class="cov0" title="0">{
                        affiliations[i] = affiliation.SID
                }</span>
                <span class="cov0" title="0">authors[i] = database.Author{
                        Name:      author.Name,
                        GivenName: author.GivenName,
                        Surname:   author.Surname,
                        Initials:  author.Initials,
                        SID:       author.SID,
                        AffilIDs:  affiliations,
                }</span>
        }
        <span class="cov0" title="0">return authors</span>
}

func (entry *Entry) getAffiliations() []database.Affiliation <span class="cov0" title="0">{
        affiliations := make([]database.Affiliation, len(entry.Affiliations))
        for i, affiliation := range entry.Affiliations </span><span class="cov0" title="0">{
                alias := make([]string, len(affiliation.Alias))
                for j, name := range affiliation.Alias </span><span class="cov0" title="0">{
                        alias[j] = name.Name
                }</span>
                <span class="cov0" title="0">affiliations[i] = database.Affiliation{
                        SID:     affiliation.SID,
                        Name:    affiliation.Name,
                        City:    affiliation.City,
                        Country: affiliation.Country,
                        Alias:   alias,
                }</span>
        }
        <span class="cov0" title="0">return affiliations</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package update

import (
        "bytes"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "os"
        "strings"

        "github.com/alexgiesting/gillings-search/go/database"
        "github.com/alexgiesting/gillings-search/go/paths"
)

type Searchable struct {
        ID      string   `json:"id"`
        Text    string   `json:"_text_"`
        Title   string   `json:"title"`
        PubType string   `json:"pubtype"`
        PubName string   `json:"pubname"`
        Date    string   `json:"date"`
        CitedBy int      `json:"citedby"`
        Author  []string `json:"author"`
        SID     []string `json:"sid"`
}

func pushCitations(db *database.Connection) <span class="cov0" title="0">{
        var citations []database.Citation
        db.Citations.Decode(&amp;citations)

        searchables := make([]Searchable, len(citations))
        for i, citation := range citations </span><span class="cov0" title="0">{
                authors := make([]string, len(citation.Authors))
                sids := make([]string, len(citation.Authors))
                for j, author := range citation.Authors </span><span class="cov0" title="0">{
                        authors[j] = fmt.Sprintf("%s %s %s", author.GivenName, author.Initials, author.Surname) // TODO
                        sids[j] = author.SID
                }</span>
                <span class="cov0" title="0">searchables[i] = Searchable{
                        ID:      citation.EID,
                        Text:    fmt.Sprintf("%s %s %s", citation.Title, citation.Abstract, strings.Join(citation.Keywords, " ")), // TODO
                        Title:   citation.Title,
                        PubType: fmt.Sprintf("%s %s", citation.PubType, citation.SubType),
                        PubName: fmt.Sprintf("%s %s %s", citation.PubName, citation.Volume, citation.Issue),
                        Date:    fmt.Sprintf("%sT23:59:59Z", citation.ISODate),
                        CitedBy: citation.CitedByCount,
                        Author:  authors,
                        SID:     sids,
                }</span>
        }

        <span class="cov0" title="0">docs := make(chan []byte)
        i := 0
        j := 0
        go func() </span><span class="cov0" title="0">{
                for _, searchable := range searchables </span><span class="cov0" title="0">{
                        doc, err := json.Marshal(searchable)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                        <span class="cov0" title="0">docs &lt;- doc
                        i++
                        j++</span>
                }
                <span class="cov0" title="0">close(docs)</span>
        }()

        <span class="cov0" title="0">host, _ := os.LookupEnv(paths.ENV_SOLR_HOST)
        port, _ := os.LookupEnv(paths.ENV_SOLR_PORT)
        url := fmt.Sprintf("http://%s:%s/solr/citations/update?", host, port)
        body := make([]byte, 0, 64&lt;&lt;10)
        body = append(body, '[')
        for </span><span class="cov0" title="0">{
                doc, ok := &lt;-docs
                if ok &amp;&amp; len(body)+len(doc)+1 &lt; cap(body) </span><span class="cov0" title="0">{
                        body = append(body, doc...)
                        body = append(body, ',')
                        continue</span>
                }

                <span class="cov0" title="0">body[len(body)-1] = ']'
                log.Print(i, len(body)) // TODO
                params := "overwrite=false"
                if j &gt; 5000 </span><span class="cov0" title="0">{
                        j = 0
                        params = params + "&amp;commit=true"
                }</span>
                <span class="cov0" title="0">request, err := http.NewRequest("POST", url+params, bytes.NewBuffer(body))
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">request.Header.Set("Content-Type", "application/json")
                _, err = http.DefaultClient.Do(request)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(i, err)
                }</span>

                <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">body = append(body[:1], doc...)
                body = append(body, ',')</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package update

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "log"
        "net/http"
        "net/url"
        "os"
        "strings"
        "time"

        "github.com/alexgiesting/gillings-search/go/database"
        "github.com/alexgiesting/gillings-search/go/paths"
)

func update(db *database.Connection, r Request) <span class="cov0" title="0">{
        switch r.path </span>{
        case "pull":<span class="cov0" title="0">
                // TODO where should the date come from?
                startDate := "2021-01-01"
                pullCitations(db, startDate)</span>
        case "push":<span class="cov0" title="0">
                pushCitations(db)</span>
        case "load/faculty":<span class="cov0" title="0">
                db.Faculty.Drop(context.TODO())
                db.LoadFaculty(r.body)</span>
        case "drop/faculty":<span class="cov0" title="0">
                db.Faculty.Drop(context.TODO())</span>
        case "load/citations":<span class="cov0" title="0">
                if r.query.Get("drop") == "1" </span><span class="cov0" title="0">{
                        db.Citations.Drop(context.TODO())
                }</span>
                <span class="cov0" title="0">db.LoadCitations(r.body)</span>
        case "drop/citations":<span class="cov0" title="0">
                db.Citations.Drop(context.TODO())</span>
        case "load/themes":<span class="cov0" title="0">
                db.Themes.Drop(context.TODO())
                db.LoadThemes(r.body)</span>
        case "drop/themes":<span class="cov0" title="0">
                db.Themes.Drop(context.TODO())</span>
        default:<span class="cov0" title="0">
                log.Printf("Invalid request `%s` received by `update`", r.path)</span>
        }
}

type QueryHandler struct {
        updateKey string
        request   chan Request
}

type Request struct {
        path  string
        query url.Values
        body  *bytes.Reader
}

func (handler *QueryHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // TODO maybe not form?
        if r.FormValue("key") != handler.updateKey </span><span class="cov0" title="0">{
                // TODO use userinfo instead?
                http.Error(w, "Not authorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">path := strings.TrimRight(r.URL.Path[len(paths.PATH_UPDATE):], "/")
        var body *bytes.Reader
        if path[:len("load")] == "load" </span><span class="cov0" title="0">{ // TODO I think this throws if the path is too short?
                file, _, err := r.FormFile("file")
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">bodyBytes, err := io.ReadAll(file)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">body = bytes.NewReader(bodyBytes)</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "text/plain; charset=utf-8")
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.WriteHeader(http.StatusAccepted)
        fmt.Fprintln(w, "command received")

        handler.request &lt;- Request{path, r.Form, body}</span>
}

func Main() <span class="cov0" title="0">{
        db := database.Connect()
        defer db.Disconnect(context.TODO())

        updateKey, err := os.ReadFile(paths.SECRET_UPDATE_KEY)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">serveMux := http.NewServeMux()
        handler := QueryHandler{string(updateKey), make(chan Request)}
        serveMux.Handle(paths.PATH_UPDATE, &amp;handler)
        PORT := os.Getenv(paths.ENV_UPDATE_PORT)
        log.Printf("Running server on %s", PORT)
        go func() </span><span class="cov0" title="0">{ log.Fatal(http.ListenAndServe(":"+PORT, serveMux)) }</span>()

        <span class="cov0" title="0">ticker := time.NewTicker(24 * time.Hour)
        defer ticker.Stop()
        defer log.Fatal("Update ended?")
        for </span><span class="cov0" title="0">{
                select </span>{
                case r := &lt;-handler.request:<span class="cov0" title="0">
                        update(db, r)</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        pullCitations(db, "2021-01-01")</span> // TODO generate date
                }
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
